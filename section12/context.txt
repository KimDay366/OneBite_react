Context 란?
: 컴포넌트 간의 데이터를 전달하는 또 다른 방법
: 기존의 Props가 가지고 있던 단점을 해결 할 수 있음
: 여러개의 Context를 만들어 데이터 분리도 가능함

Props의 단점 : 부모 -> 자식 의 관계로만 데이터 전달이 가능, 자식의 아래 손자 컴포넌트에게 전달하려면 자식을 꼭 거쳐야함 
( = Props Drilling)

- Props 사용 시 선언한 이름으로 모든 변수명을 쓰는게 개발자 규칙 
   -> Props Drilling으로 작업 시 하나의 이름이 바뀌면 나머지 모든 이름을 바꿔주어야 함


[ Context 사용법 ]
: 데이터를 전달 할 부모 컴포넌트 (투두에서는 App.jsx)에서 선언

import {context} from 'react';

const TodoContext = createContext();
// App() 바깥에 선언! 
// 하위 컴포넌트에 데이터만 전달하는 용도이므로 리렌더링 되지 않도록!

// 선언 후 본문에서 데이터를 넘겨야 하는 컴포넌트를 해당 변수로 묶고
//  value={{...}} 값의 객체로 전달

function App() {
  
   ... 

  return (
    <div className="App">
      <Header />

      <TodoContext.Provider value={{todos, onCreate, onUpdate, onDelete}} >
        <Editor />
        <TodoList />
      </ TodoContext.Provider>
      // 여기에 나와있지 않은 TodoItems 컴포넌트도 해당 데이터를 사용 가능

    </div>
  )
}


-> 문제점 : <TodoContext.Provider> 또한 컴포넌트로, value로 받는 값 중 새로 변경되는 것이 있으면 리렌더링 됨
            이러한 경우, 자식 컴포넌트인 "Editor, TodoList"는 물론이고 손자 컴포넌트인 "TodoItems"까지 모두 리렌더링 됨

            우리는 memo()를 사용하여 컴포넌트가 리렌더링 되지 않도록 설정 해 두었음 -> 근데 무시당함
            왜냐하면, 다른 value 가 업데이트 되면 당연히 다른 Props도 재생성 되므로

            => 이러한 문제 때문에, 항상 변화하는 value / 특정 명령에 변화하는 value로 나누어 적용

            변경될 수 있는 값 : TodoStateContext.Provider value={todos}
            변경되지 않는 값  : TodoDispatchContext.Provider value={{onCreate, onUpdate, onDelete}}