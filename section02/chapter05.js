// 원시 타입 vs 객체 타입


// 원시 타입 : 값 자체로써 변수에 저장되고 복사된다
//          numver, string, boolean 등등..
// 예) P1 = 1 로 선언하면 메모리에 1이 저장됨. 이름이 P1으로 붙여짐.
//     다시 P1 = 2를 선언하면 새로운 메모리에 2가 저장되고, P1 이름이 이동.
// 메모리가 수정되는 것이 아니라 신규 생성되고 이름이 이동하는 구조이기 때문에 메모리가 쌓임. => 불변값(원본 데이터가 영원히 살아 있다는 뜻)

// ------------------------------------------------------------------

// 객체 타입 : 참조값(=주소)을 통해 변수에 저장되고 복사된다
//          object, array, function 등
// 예) 
// let o1 = {a:1};
// let o2 = o1;

// console.log(o2); = {a:1}

// o2.a = 3;

// console.log(o1); = {a:3}
// console.log(o2); = {a:3}

// 예시처럼 참조값 1개에 2개의 이름이 붙는 것이고, 
// 두번째 이름을 통해서 값을 바꾸면 
// 같은 참조를 사용하는 것이기 때문에 값이 같이 바뀜 (=가변값, 사이드이팩트)

// -------------------------------------------------------------------

// 객체 타입 주의사항 

// 1. 의도치 않게 값이 수정될 수 있다.
//  => let o2 = o1;로 사용하지 않고 (=얕은 복사 : 원본 참조값 복사, 위험)
//     let o2 = {...o1}; spread 형식 사용해, 복사 및 신규 참조 선언하기
//     ( = 깊은 복사 : 새로운 객체로 생성 후 복사함, 원본 수정 안되 안전)


// 2. 객체간의 비교는 기본적으로 참조값을 기준으로 이루어진다
// let o1 = {a:1};
// let o2 = o1;
// let o3 = {...o1};

// console.log(o1 === o2); -> True 출력, 같은 참조를 쓰기 때문에
// console.log(o1 === o3); -> False 출력, 값은 같지만 참조가 다름
// (= 얕은 비교, 참조값을 기준으로만 비교하고 그 안에 든 내용 비교 안함)

// console.log(JSON.stringify(o1)===JSON.stringify(o3)); 
// -> True 출력, 순수하게 값에 대해서만 비교하는 JSON 내장함수
// (= 깊은 비교, 객체를 문자열로 변환하여 순수 값만 비교)


// 3. 배열과 함수도 사실 객체이다
// 따라서 추가적인 프로퍼티, 매서드 등을 가질 수 있다
// (하지만 깊은 내용은 생략)
