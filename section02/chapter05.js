// 원시 타입 vs 객체 타입


// 원시 타입 : 값 자체로써 변수에 저장되고 복사된다
//          numver, string, boolean 등등..
// 예) P1 = 1 로 선언 => 메모리에 1이 저장 + 이름이 P1으로 붙여짐.
//     다시 P1 = 2를 선언 => 새로운 메모리에 2가 저장되고, P1 이름이 새로운 메모리로 이동.
//                          이전에 저장된 1은 메모리에 그대로 있는 것으로, 메모리의 값이 수정되는 게 아님

// 원시 타입 = 불변값(원본 데이터가 영원히 살아 있다는 뜻)
// : 값 변경 시 메모리가 수정되는 것이 아니라, 신규 메모리에 값이 저장되고 해당하는 이름이 값으로 이동하는 구조이기 때문에 메모리가 쌓임.

// ------------------------------------------------------------------

// 객체 타입 : 메모리에 저장 된 데이터를, 참조값(= 메모리가 저장된 주소)을 통해 불러온다.
//           만약 다른 변수에 동일한 데이터로 복사하면, 원시타입 처럼 값이 복사되고 이름이 붙는 것이 아니라
//           해당 객체의 참조값(= 메모리가 저장된 주소)을 복사하여 새로운 변수에 할당한다.
//           즉, 두 변수는 같은 메모리 주소를 참조하게 되고 하나의 값을 공유하게 된다.
//          object, array, function 등
// 예) 
// let o1 = {a:1};
// let o2 = o1;

// console.log(o2); = {a:1}

// o2.a = 3;

// console.log(o1); = {a:3}
// console.log(o2); = {a:3}

// 예시처럼 참조값 1개에 2개의 변수가 붙는 것이고, 
// 두번째 변수를 통해서 값을 바꾸면 o1과 o2가 값을 공유하고 있으므로,
// 두개의 값이 같이 바뀌는 것처럼 보인다 

// 객체타입 =가변값 (사이드이팩트, 즉 원본 데이터가 수정되어 다른 변수에 영향을 줄 수 있다는 뜻)

// -------------------------------------------------------------------

// 객체 타입 주의사항 

// 1. 의도치 않게 값이 수정될 수 있다.
//  => let o2 = o1;로 사용하지 않고 (=얕은 복사 : 원본 참조값 복사, 위험)
//     let o2 = {...o1}; spread 형식 사용해, 복사 및 신규 참조 선언하기
//     ( = 깊은 복사 : 새로운 객체로 생성 후 복사함, 원본 수정 안되 안전)


// 2. 객체간의 비교는 기본적으로 참조값을 기준으로 이루어진다
// let o1 = {a:1};
// let o2 = o1;
// let o3 = {...o1};

// console.log(o1 === o2); -> True 출력, 같은 참조를 쓰기 때문에
// console.log(o1 === o3); -> False 출력, 값은 같지만 참조가 다름
// (= 얕은 비교, 참조값을 기준으로만 비교하고 그 안에 든 내용 비교 안함)

// console.log(JSON.stringify(o1)===JSON.stringify(o3)); 
// -> True 출력, 순수하게 값에 대해서만 비교하는 JSON 내장함수
// (= 깊은 비교, 객체를 문자열로 변환하여 순수 값만 비교)


// 3. 배열과 함수도 사실 객체이다
// 따라서 추가적인 프로퍼티, 매서드 등을 가질 수 있다
// (하지만 깊은 내용은 생략)
