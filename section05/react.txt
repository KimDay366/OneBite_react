section 05. react 입문

component : HTML 요소를 반환하는 함수, 재사용 가능한 UI 블록, 
            function 또는 const로 선언 가능하며, 대문자 이름으로 생성해야 함
            이렇게 명명한 명칭은 해당 컴포넌트의 이름이 됨
            보통은 컴포넌트 별로 파일을 분리하여 관리함

[ 함수 선언식 ]
function Header() {
  return (
    <header>
      <h1>Header Component</h1>
    </header>
  );
} 

[ 화살표 함수 ] 
const Footer = () => {
  return (
    <footer>
      <p>Footer Component</p>
    </footer>
  );
}; 

[ 컴포넌트 선언 하기 ]
    - 바닐라 자바스크립트 처럼 export & import를 통해 서로 연결
    - 렌더링 할 순서에 맞추어, 외부 파일 컴포넌트를 순서대로 배치

    import Header from './components/Header.jsx';
    import Main from './components/Main.jsx';
    import Footer from './components/Footer.jsx';

    function App() {

    return (
        <>
        <Header />
        <Main />
        <Footer />
        </>
    )
    }

    - 부모 컴포넌트 : 상위에 있는 컴포넌트, App 컴포넌트도 포함, 
                    (APP 컴포넌트는 주로 "조상, root 컴포넌트"로 칭함)
    - 자식 컴포넌트 : Header, Main, Footer 컴포넌트


==========================================================================


[ JSX란? Javascript Extensions ]
    확장된 자바스크립트 문법으로, React파일 안에서 HTML을 혼용하여 사용 할 수 있는 문법

    [예시]

    function text(){
        const myName = 'js';
        const temp = `<p> 내 이름은 ${myName} 이야 </p>`

        return temp 
    }

    function textJSX(){
        const myName = 'hj';
        return(
            <p> 내 이름은 {myName}이야 </p>
            )
    }

< 주의 사항 >
1. 중괄호 내부에는 자바스크립트 표현식만 넣을 수 있다 
   : 연산자, 삼항 연산자, 변수 / 상수는 입력이 가능하지만, 
     if문 또는 for문 같은 형식은 사용이 불가능함 (한 줄로 값의 표현이 불가능 함)

2. 숫자, 문자열, 배열의 값만 렌더링 된다
   : undefined, boolean, null, 객체(전체) 와 같은 값들은 출력으로 나오지 않음
   : 객체의 경우 객체 이름과 키값을 같이 쓰면 value값 표현 가능

3. 모든 태그는 닫혀 있어야 한다
   : <img> 태그 같이 단일로 사용하는 태그라 할 지라도, 꼭 태그를 닫아 주어야 오류가 발생하지 않음
     (셀프 클로징 <img />도 가능)

4. 최상위 태그는 반드시 하나여야만 한다
   : 즉, return() 바로 아래로 내려오는 태그가 반드시 하나여야 함. 
     컴포넌트를 만들다 보면 애매한 경우가 생기는 데, 그럴 떄에는 <></> 이렇게 빈 태그로 처리 가능

[예시]

function sample(){
    const num = 10;

    const numGroup = {
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
    }

    return (
        <section>
            <p>{if(){사용 불가}}</p>
            <p>number is {num}</p>
            <p>이 숫자는 {num % 2 === 0 ? '짝수' : '홀수'}입니다.</p>
            <p>{numGroup.two}</p>
        </section>
    );

    = return <>
        <p>이렇게 쓸 수 있음</p>
    </>
}



==========================================================================

[ JSX에서 Dom 요소에 스타일 적용하기 ]

1. 직접 작성하기
    : 표기 할 때는 "객체"로 설정하기 때문에 중괄호 2개를 사용하고, value값은 문자열 ''로 표기
      속성값 중 -(dash)사용 대신 카멜표기법(대문자)으로 대체하여 사용
      내용이 길어질 경우, 가독성이 떨어짐

<div style={{ backgroundColor: 'lightblue', padding: '5px' , border : 0, borderBottom: '5px solid blue'}}></div>

2. .css 파일을 만들어 사용하기 
    : 컴포넌트 별로 파일을 만들어서 사용
      단, 클래스를 만들어 적용 할 경우 JSX문법 내 사용 시 <div className = "class"> 로 사용해야 함
      (class를 써도 작성은 되는데, 엄격한 문법을 사용하게 되면 문제가 생기고 추후 복잡한 개발에서도 걸림돌이 될 수 있음)


=============================================================================

[ Props란? ]
    컴퍼넌트의 태그에 전달하는 값, propertis의 줄임말, *** react를 대표하는 기능 *** 
    부모 컴퍼넌트에서 설정한 값을 자식 컴포넌트에 전달할 때 주로 사용

    [자식] Button.jsx 로 컴퍼넌트 생성
    const Button = (props)=>{
      return <> <button style = {{color : props.fc}}> {props.text} </button> </>
    }

    [부모] App.jsx 내 선언 후 Props 데이터 전달
    <Button text={'메일'} fc={'#123456'} /> => '메일', '#123456'가 Props

    => Props는 기본적으로 객체 구조를 가지고 있으므로, 한번에 선언할 때는 (props)로 써도 되지만
       객체 각각 선언하여 기본값 등을 설정 할 때에는 ({text, fc="#222"}) 같이 중괄호(=객체) 안에 적어야 함수

    Button 컴퍼넌트를 각각 설정
    const Button = ({text, fc="#222"})=>{
      return <> <button style = {{color : fc}}> {text} </button> </>
      // 이때에는 props.은 생략하여 사용
    }


=============================================================================

[ Event Handling ]
    : event - 웹 내부에서 발생하는 사용자의 행동(버튼 클릭, 메세지 입력, 스크롤 등)
    : handling - 다루다, 취급하다의 의미를 가짐 
    => 이벤트가 발생 했을때 그것을 처리하는 것 (예시 - 버튼을 클릭하는 경우, 경고창이 나오게 한다 등)

    const ClickButton = ({text}) => {
        const onBtnClick = ()=>{console.log(text)};
        return <button onClick = {onBtnClick} ></button>
    }


이벤트 객체 : 특정 명령어에 대한 결과, 각 브라우저 마다 결과값의 표현 방식이 모두 다름 
            예시, 크롬 브라우저의 target = 사파리의 ETarget = 인터넷 익스플로러는 지원 안함


합성 이벤트(Synthetic Base Event)란 ? 

    모든 웹 브라우저의 이벤트 객체를 하나로 통일한 형태로 크로스 브라우징 이슈를 해결
    모든 웹 브라우저에서 사용 할 수 있도록 포맷팅 해 줌

    이벤트 확인 방법 

    const FindSynEvent = () => {

        const onSynEvent = (e)=>{ console.log(e) }; // console창에 Synthetic Base Event 객체가 출력됨
        
        return <button onClick = { onSynEvent } ></button>
    }

    export default FindSynEvent;



===================================================================================================


[ State - 상태 관리하기 ]
    : 현재 가지고 있는 형태나 모양을 정의, 변화할 수 있는 동적인 값
    : 컴포넌트의 현재 상태를 보관하는 변수 => State의 값에 따라 렌더링 되는 UI가 결정 됨 (리-렌더 / 리-렌더링)

    : State는 React에서 제공 해 주는 컴포넌트이므로, import { useState } from 'react' 로 당겨와 사용해야 함
    : useState() : [초기값, 값 저장 함수]의 객체 형태로 구조가 정해져 있음, 
                   따라서 초기 셋팅 시 const [state, setState] = useState();로 사용하고, 
                   '초기값'을 할당하여 사용하고 싶은 경우  const [state, setState] = useState(초기값);을 넣으면 됨

+ useState()를 사용하는 이유
    : 일반 변수로 값을 저장한 뒤, 값이 변화 하는 경우에는 리-렌더링이 일어나지 않음
    : 따라서 useState()를 사용하여 값이 변화한다는 것을 react가 인지하게 해야 함


===================================================================================================

[ State & Props & 리-렌더링 관계 ]

- 리-렌더링이 일어나는 상황
  1. 저장되어 있는 state 값이 변경 되는 경우 : 꼭 보여지는 state가 아니더라도 저장된 값 자체가 변경되면 리-렌더링 진행
    [예시] setState의 함수에 의해 state 값이 변하면서, 해당 값이 속해있는 App() 전체가 리-렌더링 됨
      
  2. 제공받은 props의 값이 변경되는 경우 : 태그에 제공 받은 props의 값이 어떠한 경우에 의해 변경되는 리-렌더링 진행
    [예시] setState의 함수에 의해 state 값이 변하면서 text로 제공받은 props <h2>state : {state}</h2> 값이 변하기 때문에 리렌더링 진행

  3. 부모 컴퍼넌트가 변경되면 자식 컴퍼넌트가 리-렌더링 됨
    [예시] App() 컴퍼넌트가 리렌더링 되면서 자식으로 있는 Buld() 컴퍼넌트도 리-렌더링 됨

[ 예시 ]
function Buld(){ ... }

function App() {
  const [state, setState] = useState(0);
  const [ light, setLight ] = useState("OFF"); 

  return <>
    <div>
        <h2>state : {state}</h2>
        <button onClick={ ()=>{ setState( state + 1 ); }}>+1</button>
    </div>
    <div>
        <h2>{light}</h2>
        <Bulb light={light}/>

        <button onClick={()=>{ setLight( light==="OFF"? "ON" : "OFF"); }}>{light === "OFF"? "ON" : "OFF"} </button>
    </div>
  </>
}

=> 이처럼 state, props, component가 모두 모여있게 되면 관련 없는 상황에도 리-렌더링 되므로 과부화가 걸릴 수 있음 
   따라서, 개발 시 각각 필요한 위치에서 가동되게끔 환경을 만들어 주어야 함

[예시 수정] 

const Bulb = ()=>{ 
  const [ light, setLight ] = useState("OFF"); 
  return <> ... </>
};

const Counter = ()=>{
    const [state, setState] = useState(0); 
    return ( ... );
};

function App() {   

  return <>
    <Bulb />
    <Counter />
  </>
  
}


======================================================================================

State 사용해서 사용자 입력 값 관리하기

const Register = () =>{
  const [name, setName] = useState("이름");
    const onChangeName = (e)=>{
        //console.log(e); // Synthetic... > target > value : "사용자가 입력 한 값 출력"
        setName(e.target.value);
    }

  return <>
    <div>Register</div>
    <form action="">
        <div>
            <label htmlFor="userName">이름</label>
            <input onChange={onChangeName} value={name} id="userName" placeholder ={"이름"}/>
            <span>작성 값 : {name}</span>
        </div>
    </form>
    </>
}

export default Register;

Form 입력할 갯수가 많아지면 반복되는 선언문과 핸들러구문이 많아져서 이것을 줄이기 위해
비슷한 역할을 하는 것끼리 묶어서 하나의 함수와 state로 구성



======================================================================================

useRef 란?
리엑트에서 제공하는, 새로운 Reference 객체를 생성하는 기능
import {useRef} from 'react';
const refObject = useRef();

[ useRef vs useState 비교하기 ]

            useRef      |      useState
--------------------------------------------------------------
             컴포넌트 내부의 변수로 활용 가능
  Reference 객체를 생성   |     State를 생성
  어떤 경우에도 리렌더링 x  |  값이 변경되면 컴포넌트 리렌더링 진행


+ useRef()를 사용하는 이유
    : 일반 변수로 지정해서 사용 할 경우, 리렌더링이 이뤄질 떄마다 해당 변수도 초기화 됨
    : 따라서 리렌더링의 진행과 상관없이 값을 유지하여 사용하려면 useRef()가 필요함
    : 컴포넌트 본문 외부에 변수를 설정하여 전역으로 사용하는 경우, 
      해당 컴포넌트를 2번 이상 불러 올 때 해당 변수가 각각이 아닌 1개로 인식되어 원하는 결과를 도출할 수 없음 
      

======================================================================================

React Hooks : 클래스 컴포넌트의 기능을 함수 컴포넌트에서도 이용할 수 있도록 도와주는 매서드들

[특징]
1. 기능 앞에 use가 붙어서 사용됨
 - useState = State 기능을 낚아채오는 Hook
 - useRef = Reference 기능을 낚아채오는 Hook
 - useEffect, useReducer 등 20개 정도의 Hooks가 존재함

2. Hooks는 함수(function) 안에서만 존재할 수 있으며, 조건문 / 반복문 같은 문법 안에서는 사용이 불가능 함. 
(함수 내에서 선언하여 조건문/반복문에 변수로 사용 할 수 있도록 전달해야함)

3. 나만의 Hook 제작도 가능 (Custom Hook)