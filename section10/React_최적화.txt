
[ 최적화 란? ]
    : 웹 서비스의 성능을 개선하는 모든 행위를 일컫음
    : 아주 단순한 것 부터 아주 어려운 방법까지 매우 다양함

    1. 일반적인 웹 서비스 최적화 방법
        - 서버의 응답 속도 개선
        - 이미지, 폰트, 코드파일 등의 정적 파일 로딩 개선
        - 불필요한 네트워크 요청 줄임

    2. React APP 내부의 최적화 방법
        - 컴포넌트 내부의 불필요한 연산, 함수 재생성, 리렌더링 방지


========================================================================

1. useMemo - 연산 최적화

Memoization 
    : [메모해두기, 기억해 두기] 라는 뜻을 가진 단어로, 
      반복적으로 수행되는 동일한 연산의 경우, 그 결과값을 메모리에 저장 해 두었다가 
      다시 연산이 실행 될 경우 연산 작업을 다시 하지 않고 기존 메모리를 불러오는 방식의 작업을 의미 

    => useMemo : Memoization 기법으로 불필요한 연산의 최적화를 하는 리액트 훅

[ useMemo 사용하기]        
    const {totalCount, doneCount, notDoneCount} = useMemo(()=>{

        console.log('reRendering');

        const totalCount = todos.length;
        const doneCount = todos.filter((todo)=> todo.isDone).length; 
        const notDoneCount = totalCount - doneCount;

        return {totalCount, doneCount, notDoneCount}

    }, [todos]);
    // 의존성 배열, deps
    // 두번쨰 인자인 배열[]의 값이 변화할 경우에만 첫번째 인자인 콜백함수를 실행
    // 따라서 [todos]의 배열이 바뀌면 그때 앞쪽 계산이 이루어짐


    return <div className="todoList">
            <h4>Todo List ⭐</h4>
            <div>
                <div>Total : {totalCount}</div>
                <div>Finish : {doneCount}</div>
                <div>Not Done : {notDoneCount} </div>
            </div>
            

========================================================================

2. React의 memo() - 컴포넌트 렌더링 최적화
    : 컴포넌트를 인수로 받아, 최적화된 컴포넌트로 만들어 반환
    : 부모 컴퍼넌트가 리렌더링 되더라도, 본인이 받는 Props가 바뀌지 않는다면 리렌더링 되지 않는 것
    const MemoizedComponent = memo(Component);

[ memo 사용법 ] 리렌더링을 진행하지 않을 자식 컴퍼넌트에 선언하고 사용
import {memo} from 'react';

const Header = ()=>{ ... }

const MemoHeader = memo(Header);

export default MemoHeader;

또는 

export default memo(Header); // 한번에 선언 가능


단, TodoItems처럼 객체형 함수를 사용하는 경우 매번 새로운 주소를 할당받아 Props가 변화했다고 판단되면 리렌더링이 발생함.
이러한 경우 콜백함수를 사용하여 특정 조건에서만 리렌더링 되도록 설정

export default memo(TodoItems, (prevProps, nextProps)=>{

    // 반환값에 따라, Props가 바뀌었는지 판단
    //  True = Props 가 안바뀜 
    //  False = Props 가 바뀜 + 리렌더링 진행 

    if(prevProps.id !== nextProps.id ) return false;
    if(prevProps.isDone !== nextProps.isDone ) return false;
    if(prevProps.content !== nextProps.content ) return false;
    if(prevProps.date !== nextProps.date ) return false;

    return true;
});
            

========================================================================

3. useCallback - 불필요한 함수 최적화

// memo() : 얉은 함수 비교, onUpdate, onDelete 함수 비교는 생략하고 진행했음. 
//          또한 모든 Props를 일일이 선택하여 비교하고 결정하였음 
// => 코드가 복잡하고, Props의 이름이 바뀌면 해당 설정도 바꿔야하며, 새로운 Props가 나오면 추가 설정을 해야하는 등 관리가 어려움

//    따라서, 애초에 onUpdate, onDelete 함수가 새로고침 되도 주소가 업데이트 되지 않으면 쉽게 해결 가능


[ useCallback 사용하기 ] 파일 App.jsx 에서 실행

  import {useCallback} from 'react'; 

  const App = ()=>{
    ...

  const func = useCallback(()=>{}, []);
  // 의존성 객체, deps : 두번쨰 인자인 배열이 바뀌면 콜백 함수가 실행 됨
  // 현재처럼 빈 배열로 둘 경우, Mount(첫 로딩) 될 때 1번만 실행되고 그 이후로는 실행되지 않음

  }

             

========================================================================

4. 최적화의 타이밍
    : 너무 이른 때에 하거나, 너무 많은 것을 설정해도 문제가 될 수 있음

    1. 하나의 프로젝트가 완성이 된 이후(기능으로 구현이 모두 이뤄 진 이후)에 최적화 실행
        => 최적화를 진행 한 이후 기능의 확장이나 업그레이드가 어려워 질 수 있기 때문

    2. 모든 모듈이 아니라 꼭 최적화가 필요한 모듈, 함수, 컴포넌트 들에 적용해야 함
        (memo 또한 연산이 필요한 연산자 이므로, 리렌더링이 빠른 컴포넌트에 적용하는건 오히려 낭비임)
        => 사용자에 의해 설정이 변경되는 컴포넌트 혹은 데이터나 함수를 많이 사용하여 복잡한 계산을 하는 컴포넌트에 사용